---
title: "PS1_code"
format: html
editor: visual
---

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

## Problem 1

### Task (a)

We read the data set first.

```{r}
data <- read.table("./wine.data", sep = ",", header = FALSE)
data <- data.frame(data)
```

And we need to name each column using information in `wine.names`.

```{r}
attribNames <- c("class", "Alcohol", "Malic acid", "Ash", "Alcalinity of ash", "Magnesium", "Total phenols", "Flavanoids", "Nonflavanoid phenols", "Proanthocyanins", "Color intensity", "Hue", "OD280/OD315 of diluted wines", "Proline")
colnames(data) <- attribNames
```

### Task (b)

Here, we check whether the column names match the class and attributes in `wine.names`.

```{r}
print(data)
```

### Task (c)

1.The wine with the highest alcohol content belongs to which class?

```{r}
data[which.max(data$Alcohol),]$class
```

2.The wine with the lowest alcohol content belongs to which class?

```{r}
data[which.min(data$Alcohol),]$class
```

3.German beers have, on average, 114 mg/l of magnesium. How many of these wines have higher levels of magnesium than that?

```{r}
averMag <- 114
length(which(data$Magnesium > averMag))
```

4.Within each class, how many wines have higher levels of magnesium than average German beer?

```{r}
num_class <- max(data$class)
for (i in 1:num_class){
  
  #Compute the number of wines for class i
  
  numWines <- length(which(((data$Magnesium > averMag) & (data$class == i)))) 
  
  #Print the result as a sentence
  
  cat("Within class ", toString(i) , ", ", toString(numWines) , " wines have higher levels of magnesium than average German beer.\n")
}
```

### Task (d)

```{r}
#table <- data.frame(matrix(0,))
#colMeans(data[,-1])

# Number of rows and number of attributes of wine data set

numRows <- dim(data)[1]
numAttrib <- dim(data)[2]-1

# Create an empty table to contain the statistics computed

table <- matrix(0, nrow = 4, ncol = numAttrib)
table <- data.frame(table)

# Compute the statistics (Overall average and average within each class) and fill them in the table

table[1,] = colMeans(data[,-1])
table[2,] =colMeans(data[which(data$class == 1),-1])
table[3,] =colMeans(data[which(data$class == 2),-1])
table[4,] =colMeans(data[which(data$class == 3),-1])

# Name each rows columns
colnames(table) <- attribNames[-1]
rownames(table) <- c("Overall average", "Class 1 average", "Class 2 average", "Class 3 average")

# Print the table
print(table)
```

### Task (e)

```{r}
ashClass1 <- data[which(data$class == 1),]$Ash
ashClass2 <- data[which(data$class == 2),]$Ash
ashClass3 <- data[which(data$class == 3),]$Ash
```

Then we carry t-test on either 2 classes, respectively. Here, we just pick $\alpha = 0.05$ for convenience.

```{r}
alpha <- 0.05
names(t.test(ashClass1, ashClass2, alternative = "two.sided", conf.level = 1-alpha))
```

$$
t_1 = \frac{\hat{\beta_1}-\beta_1^0}{s.e.(\hat{\beta_1)}}
$$

## Problem 2

```{r}
#Clear the environment
rm(list=ls())
```

```{r}
isPerfectPower <- function(numCheck, power){
  root <- numCheck^(1/power)
  rootToInt <- round(root)
  if (all.equal(root, rootToInt) == TRUE){
    return(list(TRUE,root))
  }
  return(list(FALSE,root))
}
```

```{r}
findRootPower <- function(numCheck){
  if (numCheck == 1){
    return("Your input is 1. You can express it as 1^n for any natural number n.")
  }
  maxPower <- ceiling(log(numCheck, base = 2))
  for(currPower in 2:maxPower){
    returnList <- isPerfectPower(numCheck, currPower)
    isPerfect <- returnList[1]
    root <- returnList[2]
    if(isPerfect == TRUE){
      return(cat(toString(numCheck),"=",toString(root),"^",toString(currPower)))
    }
  }
  return(cat(toString(numCheck),"is not a perfect power."))
}
```

```{r}
checkList <- c(27, 13060694016, 7776, 170859375, 58247422, 94143178827)
for (i in checkList){
  findRootPower(i)
  cat("\n")
}
```

## Problem 3

### Task (a)

The following prompt was put in ChatGPT.

> Produce two R functions: The first should take in a vector of suits and a vector of ranks representing a 5-card hand, and return the name of the hand (in 5 card stud poker). The second should simulate dealing a round of cards in a game of poker (5 card stud). The user should be able to specify the number of players. Show the user all the hands, and use the first function to display the name of each of the hands.

The following code is generated by `ChatGPT`.

```{r}
# Define a function to determine the name of a poker hand
get_poker_hand_name <- function(suits, ranks) {
  if (length(unique(ranks)) == 5) {
    if (max(ranks) - min(ranks) == 4) {
      if (length(unique(suits)) == 1) {
        return("Straight Flush")
      } else {
        return("Straight")
      }
    }
  }
  if (length(unique(ranks)) == 2) {
    counts <- table(ranks)
    if (max(counts) == 4) {
      return("Four of a Kind")
    }
    if (max(counts) == 3) {
      if (min(counts) == 2) {
        return("Full House")
      }
    }
  }
  if (length(unique(suits)) == 1) {
    return("Flush")
  }
  counts <- table(ranks)
  if (max(counts) == 3) {
    return("Three of a Kind")
  }
  if (max(counts) == 2) {
    if (min(counts) == 2) {
      return("Two Pair")
    } else {
      return("One Pair")
    }
  }
  return("High Card")
}
```

```{r}
# Define a function to simulate dealing a round of poker
deal_poker_round <- function(num_players) {
  # Define the suits and ranks
  suits <- c("Hearts", "Diamonds", "Clubs", "Spades")
  ranks <- c(2, 3, 4, 5, 6, 7, 8, 9, 10, "Jack", "Queen", "King", "Ace")
  
  # Create a deck of cards
  deck <- expand.grid(Rank = ranks, Suit = suits)
  
  # Shuffle the deck
  shuffled_deck <- deck[sample(nrow(deck)), ]
  
  # Deal cards to players
  player_hands <- list()
  for (i in 1:num_players) {
    player_hands[[i]] <- shuffled_deck[(i - 1) * 5 + 1:i * 5, ]
    cat("Player", i, "hand:\n")
    print(player_hands[[i]])
    hand_name <- get_poker_hand_name(player_hands[[i]]$Suit, player_hands[[i]]$Rank)
    cat("Hand Name:", hand_name, "\n\n")
  }
}

# Example usage: Simulate a round of poker with 4 players
deal_poker_round(4)
```

Also, there is a text output generated by ChatGPT.

> These functions should allow you to simulate a round of 5-card stud poker with a specified number of players and determine the name of each player's hand using the first function.

### Task (b)

Debug function 1

```{r}
# Define a function to determine the name of a poker hand
get_poker_hand_name <- function(suits, ranks) {
  
  #print(i)
  #print("is started")
  
  # Throw error when input parameters are illegal.
  if ((length(suits) != 5) || (length(ranks) != 5)){
    stop("It is not a legal input. Case 1")
  }
  
  suitsList <- c("Hearts", "Diamonds", "Clubs", "Spades")
  for(s in suits){
    if(!(s %in% suitsList)){
      stop("It is not a legal input. Case 2")
    }
  }
  
  # Convert ranks into integers
  # "Jack", "Queen", "King", "Ace" are to be converted to 11, 12, 13, 14, respectively.
  
  
  for(j in 1:length(ranks)){
    if(identical(ranks[j], "Jack")){
      ranks[j] <- 11
    }
    if(identical(ranks[j], "Queen")){
      ranks[j] <- 12
    }
    if(identical(ranks[j], "King")){
      ranks[j] <- 13
    }
    if(identical(ranks[j], "Ace")){
      ranks[j] <- 14
    }
  }
  
  ranks <- as.numeric(ranks)
  
  if (length(unique(ranks)) == 5) {
    if (max(ranks) - min(ranks) == 4) {
      if (length(unique(suits)) == 1) {
        if (max(ranks) == 14){
          return("Royal flush")
        } else {
          return("Straight Flush")
        }
      } else {
        return("Straight")
      }
    }
  }
  
  #print("first if finished")
  
  if (length(unique(ranks)) == 2) {
    counts <- table(ranks)
    if (max(counts) == 4) {
      return("Four of a Kind")
    }
    if (max(counts) == 3) {
      if (min(counts) == 2) {
        return("Full House")
      }
    }
  }
  
  #print("second if finished")
  
  if (length(unique(suits)) == 1) {
    return("Flush")
  }
  counts <- table(ranks)
  if (max(counts) == 3) {
    return("Three of a Kind")
  }
  if (max(counts) == 2) {
    
    # Find the second largest item in counts
    if (sort(counts, decreasing = TRUE)[2] == 2) {
      return("Two Pair")
    } else {
      return("One Pair")
    }
  }
  return("High Card")
}
```

Debug function 2

```{r}
# Define a function to simulate dealing a round of poker
deal_poker_round <- function(num_players) {
  
  if (num_players > 10){
    return("We cannot have more than 10 hands, since there are only 52 cards.")
  }
  
  # Define the suits and ranks
  suits <- c("Hearts", "Diamonds", "Clubs", "Spades")
  ranks <- c(2, 3, 4, 5, 6, 7, 8, 9, 10, "Jack", "Queen", "King", "Ace")
  
  # Create a deck of cards
  deck <- expand.grid(Rank = ranks, Suit = suits)
  
  # Shuffle the deck
  shuffled_deck <- deck[sample(nrow(deck)), ]
  
  # Deal cards to players
  player_hands <- list()
  for (i in 1:num_players) {
    player_hands[[i]] <- shuffled_deck[((i - 1) * 5 + 1):(i * 5), ] # Modified here
    cat("Player", i, "hand:\n")
    print(player_hands[[i]])
    hand_name <- get_poker_hand_name(player_hands[[i]]$Suit, player_hands[[i]]$Rank)
    cat("Hand Name:", hand_name, "\n\n")
  }
}

```

Test 2 functions

```{r}
# Example usage: Simulate a round of poker with 4 players
deal_poker_round(4)
```

Debug utility

```{r}

suits <- c("Clubs","Spades","Diamonds","Spades","Hearts")
ranks <- c(4,"Jack",9,3,3)
get_poker_hand_name(suits, ranks)
```

"Hearts", "Diamonds", "Clubs", "Spades"
